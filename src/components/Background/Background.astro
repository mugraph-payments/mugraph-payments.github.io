---
import classes from "./Background.module.css";
interface Props {}
const {} = Astro.props;
---

<script>
  class HeroBackground {
    private canvas: HTMLCanvasElement;
    private gl: WebGL2RenderingContext;
    private program: WebGLProgram;
    private positionBuffer: WebGLBuffer;
    private resolutionUniformLocation: WebGLUniformLocation;
    private timeUniformLocation: WebGLUniformLocation;
    private mouseUniformLocation: WebGLUniformLocation;
    private mouseLerpUniformLocation: WebGLUniformLocation;
    private startTime: number;
    private requestId: number | null = null;
    private uniforms: {
      mouse: { value: { x: number; y: number } };
      mouseLerp: { value: { x: number; y: number } };
    };

    constructor(canvasId: string) {
      this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;
      this.gl = this.canvas.getContext("webgl2") as WebGL2RenderingContext;
      this.startTime = Date.now();
      this.uniforms = {
        mouse: { value: { x: 0, y: 0 } },
        mouseLerp: { value: { x: 0, y: 0 } },
      };

      if (!this.gl) {
        throw new Error("WebGL2 not supported");
      }

      this.program = this.createProgram();
      this.gl.useProgram(this.program);
      this.positionBuffer = this.createPositionBuffer();
      this.resolutionUniformLocation = this.gl.getUniformLocation(
        this.program,
        "resolution",
      )!;
      this.timeUniformLocation = this.gl.getUniformLocation(
        this.program,
        "time",
      )!;
      this.mouseUniformLocation = this.gl.getUniformLocation(
        this.program,
        "mouse",
      )!;
      this.mouseLerpUniformLocation = this.gl.getUniformLocation(
        this.program,
        "mouseLerp",
      )!;

      this.resize = this.resize.bind(this);
      this.render = this.render.bind(this);
      this.handleMouse = this.handleMouse.bind(this);

      window.addEventListener("resize", this.resize);
      window.addEventListener("mousemove", this.handleMouse);

      this.resize();
      this.render();
    }

    private createProgram(): WebGLProgram {
      const vertexShaderSrc = `#version 300 es
      in vec2 position;
      out vec2 vUv;

      void main(void) {
        vUv = position;
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

      const fragmentShaderSrc = `#version 300 es
      precision highp float;

      uniform vec2 resolution;
      uniform float time;
      uniform float fft;
      out vec4 fragColor;
      uniform vec2 mouseLerp;
      in vec2 vUv;

      void main() {
        vec3 color = vec3(vUv, 0.0);
        fragColor = vec4(color, 1.0);
      }
    `;

      const vertexShader = this.createShader(
        this.gl.VERTEX_SHADER,
        vertexShaderSrc,
      );
      const fragmentShader = this.createShader(
        this.gl.FRAGMENT_SHADER,
        fragmentShaderSrc,
      );

      const program = this.gl.createProgram()!;
      this.gl.attachShader(program, vertexShader);
      this.gl.attachShader(program, fragmentShader);
      this.gl.linkProgram(program);

      if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
        throw new Error(
          "Unable to initialize the shader program: " +
            this.gl.getProgramInfoLog(program),
        );
      }

      return program;
    }

    private createShader(type: number, source: string): WebGLShader {
      const shader = this.gl.createShader(type)!;
      this.gl.shaderSource(shader, source);
      this.gl.compileShader(shader);

      if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        throw new Error(
          "An error occurred compiling the shaders: " +
            this.gl.getShaderInfoLog(shader),
        );
      }

      return shader;
    }

    private createPositionBuffer(): WebGLBuffer {
      const positionBuffer = this.gl.createBuffer()!;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);
      this.gl.bufferData(
        this.gl.ARRAY_BUFFER,
        new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
        this.gl.STATIC_DRAW,
      );

      const positionLocation = this.gl.getAttribLocation(
        this.program,
        "position",
      );
      this.gl.enableVertexAttribArray(positionLocation);
      this.gl.vertexAttribPointer(
        positionLocation,
        2,
        this.gl.FLOAT,
        false,
        0,
        0,
      );

      return positionBuffer;
    }

    private resize() {
      this.canvas.width = this.canvas.clientWidth;
      this.canvas.height = this.canvas.clientHeight;
      this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      this.gl.useProgram(this.program);
      this.gl.uniform2f(
        this.resolutionUniformLocation,
        this.canvas.width,
        this.canvas.height,
      );
    }

    private render() {
      this.gl.useProgram(this.program);

      this.gl.uniform1f(
        this.timeUniformLocation,
        (Date.now() - this.startTime) / 1000.0,
      );

      this.uniforms.mouseLerp.value.x = this.lerp(
        this.uniforms.mouseLerp.value.x,
        this.uniforms.mouse.value.x,
        0.05,
      );
      this.uniforms.mouseLerp.value.y = this.lerp(
        this.uniforms.mouseLerp.value.y,
        this.uniforms.mouse.value.y,
        0.05,
      );

      this.gl.uniform2f(
        this.mouseLerpUniformLocation,
        this.uniforms.mouseLerp.value.x,
        this.uniforms.mouseLerp.value.y,
      );
      this.gl.uniform2f(
        this.mouseUniformLocation,
        this.uniforms.mouse.value.x,
        this.uniforms.mouse.value.y,
      );

      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
      this.requestId = requestAnimationFrame(this.render);
    }

    private handleMouse(event: MouseEvent) {
      this.uniforms.mouse.value.x =
        (event.clientX - window.innerWidth / 2) * 0.01;
      this.uniforms.mouse.value.y =
        (event.clientY - window.innerHeight / 2) * 0.01;
    }

    private lerp(start: number, end: number, amt: number): number {
      return (1 - amt) * start + amt * end;
    }

    public destroy() {
      if (this.requestId) {
        cancelAnimationFrame(this.requestId);
      }
      window.removeEventListener("resize", this.resize);
      window.removeEventListener("mousemove", this.handleMouse);
      this.gl.deleteProgram(this.program);
      this.gl.deleteBuffer(this.positionBuffer);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    new HeroBackground("background-view");
  });
</script>

<div class="relative">
  <slot />
  <div class={classes.background}>
    <canvas id="background-view" class={classes.canvas}> </canvas>
  </div>
</div>
