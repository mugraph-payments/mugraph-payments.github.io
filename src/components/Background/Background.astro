---
import classes from "./Background.module.css";
interface Props {}
const {} = Astro.props;
---

<script>
  import * as THREE from "three";
  import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
  import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
  import {
    fragmentShader as galaxyFragmentShader,
    vertexShader as galaxyVertexShader,
  } from "./shaders/galaxy";
  import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

  class HeroBackground {
    private scene: THREE.Scene;
    private renderer: THREE.WebGLRenderer;
    private composer: EffectComposer;
    private renderScene: RenderPass;
    private clock: THREE.Clock;
    private time = 0;
    private delta = 0;
    private camera: THREE.PerspectiveCamera;
    private galaxyMesh: THREE.Points;

    private settings = {
      antialias: true,
      cameraPosition: [0, -100, 200],
      aspect: window.innerWidth / window.innerHeight,
      near: 0.1,
      far: 1000,
      fov: 75,
      zoom: 1,
      gridHelper: false,
      orbitControls: true,
      autoRotate: false,
    };

    private canvas: HTMLCanvasElement;

    private requestId: number | null = null;
    private uniforms: {
      [key: string]: THREE.IUniform;
    };

    constructor(canvasId: string) {
      this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;
      this.uniforms = {
        mouse: { value: { x: 0, y: 0 } },
        mouseLerp: { value: { x: 0, y: 0 } },
        size: { value: 1 },
        t: { value: 0 },
        z: { value: 0 },
        pixelRatio: { value: window.innerHeight },
        time: { value: this.time },
        delta: { value: this.delta },
      };

      this.clock = new THREE.Clock();

      this.scene = new THREE.Scene();
      const { fov, aspect, near, far } = this.settings;
      this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      const [cameraX, cameraY, cameraZ] = this.settings.cameraPosition;
      this.camera.position.set(cameraX, cameraY, cameraZ);

      this.scene.background = new THREE.Color(0x090c1b);
      this.renderer = new THREE.WebGLRenderer({
        canvas: this.canvas,
        antialias: this.settings.antialias,
        alpha: true,
      });
      this.renderer.setClearAlpha(0);
      this.renderer.setPixelRatio(1);
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.toneMapping = THREE.ACESFilmicToneMapping;

      this.composer = new EffectComposer(this.renderer);
      this.composer.setSize(window.innerWidth, window.innerHeight);

      this.renderScene = new RenderPass(this.scene, this.camera);
      this.composer.addPass(this.renderScene);

      this.resize = this.resize.bind(this);
      this.render = this.render.bind(this);
      this.handleMouse = this.handleMouse.bind(this);

      window.addEventListener("resize", this.resize);
      window.addEventListener("mousemove", this.handleMouse);

      let galaxyMaterial = new THREE.ShaderMaterial({
        vertexShader: galaxyVertexShader,
        fragmentShader: galaxyFragmentShader,
        uniforms: this.uniforms,
        transparent: true,
        depthTest: false,
        blending: THREE.AdditiveBlending,
      });

      let starPositions = this.createGalaxBuffer();
      let galaxyGeometry = new THREE.BufferGeometry();
      galaxyGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(starPositions, 3),
      );

      this.galaxyMesh = new THREE.Points(galaxyGeometry, galaxyMaterial);
      this.scene.add(this.galaxyMesh);

      let orbitControls = new OrbitControls(
        this.camera,
        this.renderer.domElement,
      );
      orbitControls.enabled = this.settings.orbitControls;
      orbitControls.autoRotateSpeed = 0.5;
      orbitControls.autoRotate = this.settings.autoRotate;

      if (this.settings.gridHelper) {
        const gridHelper = new THREE.GridHelper(10, 10);
        this.scene.add(gridHelper);
      }

      this.resize();
      this.render();
    }

    /* Adapted from https://codepen.io/Astrak/pen/BoBWPB for now */
    private createGalaxBuffer(
      starCount = 10000,
      axis1?: number,
      axis2?: number,
      armsAngle?: number,
      bulbSize?: number,
      ellipticity?: number,
    ): Float32Array {
      let stars = new Float32Array(starCount * 3);

      let scale = 100;
      // to get 'arms', the main galaxy shape has to be an ellipse, i.e. axis1/axis2 must raise over a certain %
      // otherwise, because of the 'ellipticity' z-profile problem, you get a potato
      // axis1 = axis1 ?? scale + Math.random() * (0.2 * scale);
      // axis2 = axis2 ?? axis1 + scale * 0.5 + Math.random() * (0.2 * scale);
      axis1 = axis1 ?? 60 + Math.random() * 20;
      axis2 = axis2 ?? axis1 + 20 + Math.random() * 40;

      // make sure axis1 is the biggest (eccentricity equation fails if they are inverted), and allow the coder not to care about axis order
      let maja: number, mina: number;
      if (axis1 > axis2) {
        maja = axis1;
        mina = axis2;
      } else if (axis1 === axis2) {
        maja = axis1 + 1;
        mina = axis2;
      } else {
        maja = axis2;
        mina = axis1;
      }

      // radians from the center to the end of each arm, proposed value range: between 3 and 13
      armsAngle = armsAngle ?? (Math.random() * 2 - 1 > 0 ? 1 : -1) * 12 + 3;

      // core proportion in the (x,y) plane, between 0 and 1, proposed value range: between .1 and .8
      bulbSize =
        bulbSize === undefined
          ? Math.random() * 0.6
          : Math.max(0, Math.min(1, bulbSize));

      // 'ellipticity': not found a better word to name the degree of 'elliptic' Hubble type.
      // 'ellipticity' is what is mainly responsible for the z-profile in this experiment.
      // Range: between 0 and 1. Proposed: .2 to .4
      // TODO: implement string handling (or value from spacename?) to create Hubble-class galaxy ala 'SBb'...
      ellipticity =
        ellipticity === undefined
          ? 0.2 + Math.random() * 0.2
          : Math.max(0, Math.min(1, ellipticity));

      for (let i = 0; i < starCount; i++) {
        const dist = Math.random();
        const angle = (dist - bulbSize) * armsAngle;
        // ellipse parameters
        const a = maja * dist;
        const b = mina * dist;
        const e = Math.sqrt(a * a - b * b) / a;
        const phi =
          ((ellipticity * Math.PI) / 2) * (1 - dist) * (Math.random() * 2 - 1);
        // create point on the ellipse with polar coordinates
        // 1. random angle from the center
        let theta = Math.random() * Math.PI * 2;
        // 2. deduce radius from theta in polar coordinates, from the CENTER of an ellipse, plus variations
        const radius =
          Math.sqrt((b * b) / (1 - e * e * Math.pow(Math.cos(theta), 2))) *
          (1 + Math.random() * 0.1);
        // 3. then shift theta with the angle offset to get arms, outside the bulb
        if (dist > bulbSize) theta += angle;

        // convert to cartesian coordinates
        let { x, y, z } = {
          x: Math.cos(phi) * Math.cos(theta) * radius,
          y: Math.cos(phi) * Math.sin(theta) * radius,
          z: Math.sin(phi) * radius,
        };
        stars.set([x, y, z], i * 3);
      }

      return stars;
    }

    private resize() {
      this.canvas.width = this.canvas.clientWidth;
      this.canvas.height = this.canvas.clientHeight;
    }

    private render() {
      this.time = this.clock.getElapsedTime();
      this.delta = this.clock.getDelta();

      this.uniforms.mouseLerp.value.x = this.lerp(
        this.uniforms.mouseLerp.value.x,
        this.uniforms.mouse.value.x,
        0.05,
      );

      this.uniforms.mouseLerp.value.y = this.lerp(
        this.uniforms.mouseLerp.value.y,
        this.uniforms.mouse.value.y,
        0.05,
      );

      this.uniforms.time.value = this.time;
      this.uniforms.delta.value = this.delta;

      this.galaxyMesh.rotation.z += 0.0002;

      this.composer.render();
      this.requestId = requestAnimationFrame(this.render);
    }

    private handleMouse(event: MouseEvent) {
      this.uniforms.mouse.value.x =
        (event.clientX - window.innerWidth / 2) * 0.01;
      this.uniforms.mouse.value.y =
        (event.clientY - window.innerHeight / 2) * 0.01;
    }

    private lerp(start: number, end: number, amt: number): number {
      return (1 - amt) * start + amt * end;
    }

    public destroy() {
      if (this.requestId) {
        cancelAnimationFrame(this.requestId);
      }
      window.removeEventListener("resize", this.resize);
      window.removeEventListener("mousemove", this.handleMouse);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    new HeroBackground("background-view");
  });
</script>

<div class="relative pointer-events-auto">
  <slot />
  <div class={classes.background}>
    <canvas id="background-view" class={classes.canvas}> </canvas>
  </div>
</div>
